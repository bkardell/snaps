{"name":"Snaps","tagline":"A simple ref test runner for the rest of us.","body":"snaps\r\n=====\r\n\r\nA simple ref test runner for the rest of us.\r\n\r\n\r\nWhat's all this about?\r\n======================\r\n\r\nIn order to verify support of CSS (and maybe some small bit of other things) it relies on \"reftests\".  \r\n\r\n\r\nWhat the heck is a \"reftest\"?\r\n==============================\r\n\r\nBasically, a ref test is something that loads two versions of a Web page - one that uses well-established means to draw the page, and one that uses some new feature (the one you are testing).  It then compares the two visually and if they match, the test passes.\r\n\r\n\r\nSo why write this?\r\n==================\r\n\r\nIn a nutshell, unless you work for a vendor - it would appear that there is no way for you to run reftests yourself - for you (and apparently W3C too, it is a manual process of visual comparison).  That sucks because we want more people contributing tests for efforts like Test the Web Forward.  If you want to write a series of tests, there's no way for you to just periodically run them and see how browsers are doing.\r\nThat's one use case.  Closer to my heart though is something else: Prollyfills [The W3C Extensible Web Community Group](http://prollyfill.org) has a number of efforts to allow developers to extend the Web and propose new standards and/or work\r\nalong side working groups and browser vendors to implement evaluatable or experimental features *outside the browser itself*.  For CSS, this means we have no way to show tests and that sucks \r\nbecause as something matures, we can *totally* contribute reftests that working groups and vendors can use for the native implementations *before they even start implementing* and *while we are still standardizing*.  This would ensure that \r\nuse cases are clearly and easily communicated which helps inform and better the specs themselves.\r\n\r\n\r\nOk, I get it - so this runs W3C reftests?\r\n=========================================\r\n\r\nYes and no... W3C reftests are a little more complicated in that they contain lots of metadata describing how they are related and reported.  We're going for simple here on the \r\nfirst pass (I wrote this this morning in my hotel room) so this uses a separate file for metadata.  Still, it does the same basic thing and \r\nit can easily run/verify the same tests (metadata is non-visual) if you extract the metadata.  More importantly, this sort of thing should \r\nmake it easy enough for a WG to evaluate and pick it up even if we take it no further - and it allows me to use them for CSS related prollyfills.\r\n\r\n\r\nHow do I use it?\r\n=================\r\n* Download the jar from the /dist directory\r\n* edit the reftests.json or create your own\r\n* invoke it from the command line passing the whole path to that file\r\n\r\n```\r\n$ java -jar Snaps-1.0-SNAPSHOT.jar /full/path/to/reftests.json\r\n```\r\n\r\nThat's it... it will output some stuff to the command line and let you know what's up.  For example, if we added a bunch of browsers to the sample one provided would output:\r\n\r\n```\r\n-----------------------------------\r\nRunning tests for: firefox\r\n...fetching http://bkardell.github.io/selectors-L4-link-prollyfills/examples/local/local-links.html\r\n...fetching http://bkardell.github.io/selectors-L4-link-prollyfills/examples/local/local-links-expected.html\r\n1 of 1 passed.\r\nMay 19, 2013 6:10:07 PM org.openqa.selenium.safari.SafariDriverServer start\r\nINFO: Server started on port 43212\r\nMay 19, 2013 6:10:08 PM org.openqa.selenium.safari.SafariDriverChannelHandler$1 operationComplete\r\nINFO: Connection opened\r\n-----------------------------------\r\nRunning tests for: safari\r\n...fetching http://bkardell.github.io/selectors-L4-link-prollyfills/examples/local/local-links.html\r\n...fetching http://bkardell.github.io/selectors-L4-link-prollyfills/examples/local/local-links-expected.html\r\n1 of 1 passed.\r\n-----------------------------------\r\nRunning tests for: opera\r\n...fetching http://bkardell.github.io/selectors-L4-link-prollyfills/examples/local/local-links.html\r\n...fetching http://bkardell.github.io/selectors-L4-link-prollyfills/examples/local/local-links-expected.html\r\n1 of 1 passed.\r\nStarted ChromeDriver\r\nport=45546\r\nversion=0.8\r\nlog=/Users/bkardell/projects/java/snaps/target/chromedriver.log\r\n-----------------------------------\r\nRunning tests for: chrome\r\n...fetching http://bkardell.github.io/selectors-L4-link-prollyfills/examples/local/local-links.html\r\n...fetching http://bkardell.github.io/selectors-L4-link-prollyfills/examples/local/local-links-expected.html\r\n1 of 1 passed.\r\n```\r\n\r\nJSON Structure Explained\r\n==============\r\n\r\nThe json has four properties, the first three are optional (tests is required):\r\n* *capture_path* is a path where to capture snapshots to during testing. If not provided, snapshots aren't saved.\r\n* *regression* is a boolean property explained [here](https://github.com/bkardell/snaps#extra-fun-pixel-perfect-regressions). If not provided, it defaults to false.\r\n* *browsers* is an array of browser names to test against and an array of tests.  If not provided, it defaults to firefox.  Valid values are: firefox, chrome (see below), opera, safari, and msie (see below).\r\n* **tests** is an array of objects the only required thing is the path to the test itself (file protocol is just fine).  If you do not provide the \"expected\" property (as in the sample in this repo) it will look for \"-expected.html\" in the same place.\r\n\r\n```\r\n{\r\n  \"capture_path\": \"/path/to/capture/images/\",\r\n  \"browsers\": [\"firefox\", \"safari\", \"opera\" ],\r\n  \"tests\": [\r\n    {\r\n      \"test\": \"http://bkardell.github.io/selectors-L4-link-prollyfills/examples/local/local-links.html\",\r\n      \"expected\": \"http://bkardell.github.io/selectors-L4-link-prollyfills/examples/local/local-links-expected.html\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n\r\nA note about browsers\r\n=========================\r\nIf you want to run chrome (or msie) you'll have a bit more to do.  For chrome, you'll have to [download the appropriate driver](https://code.google.com/p/chromedriver/downloads/list) and then set \r\na property:\r\n\r\n```\r\njava -Dwebdriver.chrome.driver=/full/path/to/chromedriver2_mac32_0.8/chromedriver -jar Snaps-1.0-SNAPSHOT.jar  /full/path/to/reftests.json\r\n```\r\n\r\nUnfortunately, I don't have a PC handy, so the code support is there for MSIE, but I dont have testable instructions on how to set up the driver.  If you\r\nwant to send me a pull - much appreciated.\r\n\r\n\r\n\r\nExtra Fun: Pixel Perfect Regressions\r\n====================================\r\nIf you set the capture_path in your reftests, you can then use those captures to regression test against by simply adding a boolean regression property!\r\n\r\n```\r\n{\r\n  \"capture_path\": \"/path/to/capture/images/\",\r\n  \"regression\": true, \r\n  \"browsers\": [\"firefox\", \"safari\", \"opera\" ],\r\n  \"tests\": [\r\n    {\r\n      \"test\": \"http://bkardell.github.io/selectors-L4-link-prollyfills/examples/local/local-links.html\",\r\n      \"expected\": \"http://bkardell.github.io/selectors-L4-link-prollyfills/examples/local/local-links-expected.html\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}